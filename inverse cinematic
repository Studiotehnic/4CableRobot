
  #include <AccelStepper.h>
  
// Define robot dimensions
#define L1 200  // Length of segment 1
#define L2 200  // Length of segment 2
#define L3 200  // Length of segment 3
#define L4 200   // Length of segment 4
#define h 200   // Height of end effector above ground
#define winch_radius 20  // Radius of winch drum
#define steps_per_rev 200  // Number of steps per revolution for stepper motor
#define microsteps 16  // Microstepping mode for stepper motor

// Define pin numbers for stepper motor drivers and limit switches


//Define Constants
// Robot dimensions
// Define the coordinates of the four corners of the work volume, 0,0,0 coordonate in center off the base
const float WORKSPACE_EDGE_LENGTH = 400.0; // in mm
const float WORKSPACE_X_MIN = -WORKSPACE_EDGE_LENGTH / 2;
const float WORKSPACE_X_MAX = WORKSPACE_EDGE_LENGTH / 2;
const float WORKSPACE_Y_MIN = -WORKSPACE_EDGE_LENGTH / 2;
const float WORKSPACE_Y_MAX = WORKSPACE_EDGE_LENGTH / 2;
const float WORKSPACE_Z_MIN = 0.0;
const float WORKSPACE_Z_MAX = WORKSPACE_EDGE_LENGTH;

////////////////////////////////////////////////
// motor and winch parameters
const float steps_per_revolution = 200.0;
const float microstepping = 16.0;
const float gearbox_ratio = 4.0;
const float drum_diameter = 40.0; // mm
const float cable_length_per_revolution = drum_diameter * PI;
const float cable_length_per_step = cable_length_per_revolution / (steps_per_revolution * microstepping * gearbox_ratio);
const float cable_length_per_button_press = 50.0; // mm
const float max_cable_length = sqrt(3.0) * 200.0; // mm

const float cableDiameter = 1.0; // mm




// Limit switch distances from the corner
const int switchDistance = 50; //mm


// Acceleration and speed
const float acceleration = 100.0; // mm/s^2
const float maxSpeed = 200.0; // mm/s


// Define variables for current position and homing state
float current_x = 0.0;
float current_y = 0.0;
float current_z = 0.0;
bool is_homed = false;

// Define variables for limit switch pins
const int limit_switch_pins[4] = {18, 19, 20, 21};


// Define variables for stepper motor pins
const int stepper_pins[4][4] = {
  {2, 3, 4, 5},
  {6, 7, 8, 9},
  {10, 11, 12, 13},
  {14, 15, 16, 17}
};



// Define variables for stepper motor drivers Create motor objects
AccelStepper motor1(AccelStepper::HALF4WIRE, stepper_pins[0][0], stepper_pins[0][2], stepper_pins[0][1], stepper_pins[0][3]);
AccelStepper motor2(AccelStepper::HALF4WIRE, stepper_pins[1][0], stepper_pins[1][2], stepper_pins[1][1], stepper_pins[1][3]);
AccelStepper motor3(AccelStepper::HALF4WIRE, stepper_pins[2][0], stepper_pins[2][2], stepper_pins[2][1], stepper_pins[2][3]);
AccelStepper motor4(AccelStepper::HALF4WIRE, stepper_pins[3][0], stepper_pins[3][2], stepper_pins[3][1], stepper_pins[3][3]);

// Set the speed and acceleration of the stepper motors
  
  for (int i = 0; i < 4; i++) {
    motor[i].setMaxSpeed(500.0);
    motor[i].setAcceleration(100.0);
    motor[i].setSpeed(100.0);
  }

// Current motor positions
float motor1Position = 0.0;
float motor2Position = 0.0;
float motor3Position = 0.0;
float motor4Position = 0.0;

// Calculate cable length from motor position
float getCableLength(float motorPosition) {
  float cableLength = (motorPosition / stepsPerMicrostep) * drumDiameter * PI / transmissionRatio + sqrt(2) * workVolume / 2;
  return cableLength;
}

// Calculate motor position from cable length
float getMotorPosition(float cableLength) {
  float motorPosition = ((cableLength - sqrt(2) * workVolume / 2) * transmissionRatio) / (drumDiameter * PI) * stepsPerMicrostep;
  return motorPosition;
}

// Move motor to position
void moveMotor(AccelStepper &motor, float position) {
  float currentPosition = motor.currentPosition();
  float steps = position - currentPosition;
  motor.move(steps);
}

// Home motor
void homeMotor(AccelStepper &motor, int switchPin, float &position) {

//////// unfold motors that are not homing
float currentPosition = motor.currentPosition();
  float steps = position - currentPosition;

  // Check if motor is homing or not
  if (steps < 0) {
    // Motor is homing, move directly
    motor.move(steps);
  } else {
    // Motor is not homing, unfold cable first
    float unfoldedSteps = steps + UNFOLD_STEPS;
    motor.move(unfoldedSteps);
  }
}
  // Define variables for current position and homing state
  bool is_homed = false;

  // Home motor until limit switch is triggered
  while (!is_homed) {
    motor.setAcceleration(acceleration);
    motor.setMaxSpeed(maxSpeed);
    motor.moveTo(-1000000);
    while (motor.distanceToGo() != 0) {
      motor.run();
      if (digitalRead(switchPin) == HIGH) {
        motor.setCurrentPosition(0);
        is_homed = true;
        position = 0;
        break;
      }
    }
  }
}

// Define variables for limit switches
bool limit_switch_states[4] = {false, false, false, false};

/////////////////////////////////////////
// Define variables
float x, y, z;  // End effector position in xyz coordinates
float q1, q2;  // Joint angles
float cable_length;  // Length of cable from winch to end effector
float sin_alpha, cos_alpha;  // Sine and cosine of cable angle
long winch_steps_8, winch_steps_9, winch_steps_10, winch_steps_11;  // Steps to rotate each winch
float drum_pos_8, drum_pos_9, drum_pos_10, drum_pos_11;  // Position of winch drum
float dx, dy, dz;  // Difference between desired and actual end effector position
float error_threshold = 1;  // Error threshold for position adjustment




void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  
  // Set up limit switches as inputs with pull-up resistors
  for (int i = 0; i < 4; i++) {
    pinMode(limit_switch_pins[i], INPUT_PULLUP);
  }
  
  // Home the robot
  home();
}

  
  
////////////////////////////////////////////
void calculateCableLengths(float winchPositions[], float cableLengths[])
{
  for (int i = 0; i < NUM_WINCHES; i++) {
    float winchDistanceFromCorner = sqrt(pow(WORKSPACE_EDGE_LENGTH / 2, 2) + pow(WORKSPACE_EDGE_LENGTH / 2, 2));
    float winchDistanceFromZAxis = sqrt(pow(WORKSPACE_EDGE_LENGTH / 2, 2) + pow(WORKSPACE_EDGE_LENGTH / 2, 2));
    float winchX = winchDistanceFromCorner * cos(i * PI / 2);
    float winchY = winchDistanceFromCorner * sin(i * PI / 2);
    float winchZ = winchDistanceFromZAxis;
    float winchRadius = 20.0; // in mm

    float cableLength = sqrt(pow(winchX - winchPositions[i], 2) + pow(winchY, 2) + pow(winchZ, 2) - pow(winchRadius, 2));
    cableLengths[i] = cableLength;
  }
}

///////////////////////////////////////////////////

void calculateEffectorPosition(float cableLengths[], float effectorPosition[])
{
  float alpha1 = atan2(cableLengths[0], cableLengths[2]);
  float alpha2 = atan2(cableLengths[1], cableLengths[3]);
  float beta1 = atan2(cableLengths[0], cableLengths[1]);
  float beta2 = atan2(cableLengths[2], cableLengths[3]);

  float effectorX = (cableLengths[0] * sin(alpha2) + cableLengths[1] * sin(alpha1)) / (sin(alpha1) * cos(alpha2) - cos(alpha1) * sin(alpha2));
  float effectorY = (cableLengths[0] * cos(alpha2) + cableLengths[1] * cos(alpha1)) / (cos(alpha1) * sin(alpha2) - sin(alpha1) * cos(alpha2));
  float effectorZ = (cableLengths[2] * sin(beta2) + cableLengths[3] * sin(beta1)) / (sin(beta1) * cos(beta2) - cos(beta1) * sin(beta2));

  effectorPosition[0] = effectorX;
  effectorPosition[1] = effectorY;
  effectorPosition[2] = effectorZ;
}

////////////////////////////////////////////////////////////////

void moveMotor(AccelStepper &motor, float position) {
  float currentPosition = motor.currentPosition();
  float steps = position - currentPosition;
  motor.move(steps);
}
///////////////////////////////////////////////////////////



void loop() {
  // Read limit switch states
  for (int i = 0; i < 4; i++) {
    limit_switch_states[i] = digitalRead(limit_switch_pins[i]);
  }
  
  // Check if robot is homed
  if (!is_homed) {
    // Home the robot
    home();
  }
  
  // If robot is homed and limit switches are not triggered, move to desired position
  if (is_homed && !limit_switch_states[0] && !limit_switch_states[1] && !limit_switch_states[2] && !limit_switch_states[3]) {
    // Get desired position from inverse kinetics

  // Read input values for end effector position
  Serial.println("Enter end effector position in mm (x,y,z):");
  while (Serial.available() < 3) {}  // Wait for all values to be entered
  x = Serial.parseFloat();
  y = Serial.parseFloat();
  z = Serial.parseFloat();
  
  // Calculate joint angles
  q1 = atan2(y, x);
  float a = sqrt(x*x + y*y) - L4;
  float b = z - h;
  float c = sqrt(a*a + b*b);
  q2 = atan2(b, a) + acos((L2*L2 - L3*L3 + c*c) / (2*L2*c));
  
  // Calculate cable length and angle
  cable_length = sqrt(a*a + b*b) + L1*sin(q2);
  sin_alpha = b/cable_length;
  cos_alpha = a/cable_length;
  
  // Calculate steps to rotate each winch
  
  
  // Rotate winches to adjust cable length

  
  // Print final cable lengths and angles
  Serial.print("Cable lengths: ");
  Serial.print(cable_length + L3 + L4);
  Serial.print(", ");
  Serial.print(cable_length + L2 + L4);
  Serial.print(", ");
  Serial.println(cable_length + L2 + L3);
  
  float phi1 = atan2(y, x) - atan2(L4, cable_length + L3 + L4);
  float phi2 = PI - atan2(z - L1, sqrt(x * x + y * y - (L4 + cable_length + L3 + L1 - z) * (L4 + cable_length + L3 + L1 - z))) - atan2(L2, L4 + cable_length + L3 + L1 - z);
  float phi3 = PI - acos((L2 * L2 + L3 * L3 - (cable_length + L4) * (cable_length + L4)) / (2 * L2 * L3)) - atan2(L3 * sin(phi3), L2 + L3 * cos(phi3));
  float phi4 = atan2(L3 * sin(phi3), L2 + L3 * cos(phi3)) - atan2(cable_length, L4);
  
  

  
